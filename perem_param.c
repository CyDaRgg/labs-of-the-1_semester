// примеры реализации функций с переменным числом параметров
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <locale.h>
#include <limits.h>


////----------------------------------  пример 1  ----------------------------------------------
//void var_fun(int, ...);    // прототип ф-ции имеющей 1 постоянный параметр

//int main()
//{
//	setlocale(LC_ALL, "Russian");
//	int a1, a2, a3;
//	long int b1, b2;
//	long long int c1, c2, c3, c4;
//	printf("sizeof(char) = %d\n", sizeof(char));
//	printf("sizeof(short) = %d\n", sizeof(short int));
//	printf("sizeof(int) = %d\n", sizeof(int));
//	printf("sizeof(long int) = %d\n", sizeof(long int));
//	printf("sizeof(long long int) = %d\n", sizeof(long long int));
//	puts("введите 3 int :");
//	scanf_s("%d%d%d", &a1, &a2, &a3);            
//	var_fun(3, a1, a2, a3);                     // вызов функции с 3 параметрами типа int
//	puts("введите 2 long int :");
//	scanf_s("%ld%ld", &b1, &b2);          
//	var_fun(2, b1, b2);                         // вызов функции с 3 параметрами типа long int
//	puts("введите 4 long long int :");
//	scanf_s("%ld%ld%ld%ld", &c1, &c2, &c3, &c4);
//	var_fun(4,(long int)c1,(long int)c2,(long int)c3,(long int)c4);// вызов функции с 4 параметрами 
//	//var_fun(4,c1,c2,c3,c4);
//	                                            // типа long long int с преобразованием из в long int
//	var_fun(2, '1', '2');                       // вызов функции с 2 параметрами типа char
//	return 0;
//}
//
//void var_fun(int k, ...)        // k - количество параметров переменной длины
//{
//	
//	int s = 0;               // накопитель
//	void *p;                 // безтиповой указатель (т.е. только адрес)
//	p = (void*)&k;                  // p указатель на элемент k стека параметров
//	p = (void*)(((int *)p) + 1);      // указатель приводится к типу указателя на int 
//	// (т.е. добавляется шаг) и меняется на адрес 
//	// следующего эл-та стека
//	while (k--)              // пока в стеке есть (несчитанные) параметры
//	{
//		s += *((int *)p);
//		p = (void*)(((int *)p) + 1);   // переход к новому параметру стека
//	}
//	printf("\n сумма  элементов = %d\n", s);
//}


////----------------------------------  пример 2  --------------------------------------------
//
//#include <stdarg.h>
//
//void var_fun1(char *,...);    // прототипы 3 ф-ций имеющих 1 постоянный параметр
//void var_fun2(char *,...);
//void var_fun3(char *,...);
//
//int main()
//{
//  setlocale(LC_ALL, "Russian");
//  char *s1="aaa aaaa aaaa",         // объявляем указатели на символьные строки 
//       *s2="bb bbb b",              // и для простоты (т.е. чтобы не вводить строки)
//       *s3="cccc cccccc  ccccc",    // например, инициализируем их при этом
//       *s4=NULL;                 // указатель "пустой" 
//  var_fun1(s1,s2,s3,s4);            // три варианта вызова функций с произвольным числом параметров                
//  var_fun2(s1,s2,s3,NULL);       // (указателей на строки)
//  var_fun3(s1,s2,s3,s4);
//  puts("\n");
//}
//
//  // передача в функцию строк используя параметры переменной длинны
//  // считывание указателей на передаваемые в функцию строки осуществляется
//  // с использованием указателя на указатель типа  char     (char **p)
//void var_fun1(char*s,...)
//{ char **p;
//
//  p=&s;                     // р устанавливается на указатель(точнее адрес) находящийся на
//                            // вершине стека параметров (в рассматриваемом примере это s1)                       
//  puts("\n\n функция  - var_fun 1 -");
//  while(*p)                 // цикл пока в стеке не nullptr
//  { printf("\n%s",*p);      // разыменовывая p получаем указатель (s1, s2, ...)
//                            // выводим на экран строки, соотв. этим указателям                       
//    p++;                    // переход к новому элементу (адресу) в стеке
//  }                         // p увеличивается на величину = размеру указателя (просто указателя)
//                            // кстати, все указатели имеют один размер (равный int)
//}
//
//  // передача в функцию строк используя параметры переменной длинны
//  // считывание указателей на передаваемые в функцию строки осуществляется
//  // с использованием безтипового указателя на указатель    (void **p)
//void var_fun2(char *s,...)
//{
//  void **p;
//  p=(void **)&s;           // "убираем" у указателя в стеке его тип (приводя к void **)
//  
//  puts("\n\n функция  - fun 2 -");
//  while(*p)       // цикл пока в стеке не nullptr  (int **)p
//  { printf("\n%s",*p);  // как и в функции выше
//    p++;	             // переход к новому элементу (адресу) в стеке
//  }                        // **p можно не приволить к типу (char **)
//}                          // приращение p равно величине указателя
//
//
//  // передача в функцию строк используя параметры переменной длинны
//  // считывание указателей на передаваемые в функцию строки осуществляется
//  // с использованием макрос va_list p, va_start, va_arg и va_end
//void var_fun3(char *s, ...)
//{ va_list p;                       // это аналогично объявлению безтипового указателя  
//  va_start(p,s);                   // указатель р устанавливается на начало переменного 
//                                   // списка параметров функции
//  printf("\n%s", s);               // параметр   ("bb bbb b"), первый (постоянный),
//  puts("\n\n функция  - fun 3 -"); // то параметр ("aaa aaaa aaaa") не выводится
//  do                               
//  { s=va_arg(p, char*);            // переход к новому элементу (адресу) в стеке
//    printf("\n%s",s);              // вывод строк на экран
//  } while(s);                      // цикл пока в стеке не nullptr
//}



//----------------------------------  пример 5  ------------------------------------------

//// реализация функции с произвольным числом параметров различного типа
//// доступ к данным (параметрам) реализован с использованием void *
//// возврат вычисленных значений (двух, разного типа) выполняется с
//// использованием массива типа double
//void ** var_fun(int, ...);
//
//int main()
//{
//	setlocale(LC_ALL, "Russian");
//	double d1 = 1.1, d2 = 2.2, d3 = 3.3, d4 = 4.4;
//	//printf("%d", sizeof(long double));
//	int i1 = 5, i2 = 6, i3 = 7, i4 = 8;
//	void **ms;              // для возврата из var_fun адресов (двух) полученных сумм
//	//puts("Введите целые числа");
//	//scanf("%d%d%d%d",&i1,&i2,&i3,&i4);
//	//puts("Введите дробные числа");
//	//scanf("%f%f%f%f",&d1,&d2,&d3,&d4);
//	ms = var_fun(3, 'f', 3, d1, d2, d3, 'i', 4, i1, i2, i3, i4, 'f', 2, d3, d4);
//	puts("\n\nвывод результата в функции main :");
//	printf("\n  sum int= %d  sum float= %5.2f\n", **((int**)ms), **((double**)(ms + 1)));
//	free(ms[0]); free(ms[1]); free(ms);
//
//	return 0;
//}
//// функция суммирования чисел типа int и double
//// результаты возвращаются в main
//void ** var_fun(int n, ...)    // n-число групп
//{
//	int i, j;
//	void **sum;
//	char c;
//	//printf("%d", sizeof(sum));
//	//(void**)sum = (void **)calloc(2, sizeof(void *));      // указатель на массив из двух указателей
//	//*((int**)sum+0) = (int *)calloc(1, sizeof(int));           // указатель на элемент типа int
//	//*((double**)sum+1) = (double *)calloc(1, sizeof(double));  // указатель на элемент типа double
//
//
//
//	sum = (void **)calloc(2, sizeof(void *));      // указатель на массив из двух указателей
//	*(sum+0) = (void*)((int *)calloc(1, sizeof(int)));           // указатель на элемент типа int
//	*(sum+1) = (void*)((double *)calloc(1, sizeof(double)));
//
//	**((int**)sum + 0) = 0;
//	**((double**)sum + 1) = 0;
//
//
//	void *p ;          // p устанавливается на начало списка
//	p = (void*)&n;
//	p = (void*)((int*)p + 1);     // p передвигается на символ-тип чисел
//	while (n--)            // пока не конец всех груп
//	{
//		c = *(char *)p;    // считывание символа-типа
//		(int*)p = ((int*)p) + 1; // указатель на число переменных в группе                         var_fun(3, 'f', 3, d1, d2, d3, 'i', 4, i1, i2, i3, i4, 'f', 2, d3, d4);
//		i = *(int*)p;     // считывание числа переменных в группе
//		(int*)p = ((int*)p) + 1; // сдвиг указателя на первую переменную в группе
//		switch (c)
//		{
//		    case 'f':   
//				for (j = 0; j<i; j++)    
//		    {
//				**((double**)sum + 1) += *(double *)p;   // накопление суммы элементов double
//				p = (void*)((double*)p + 1);                    // p перемещается на следующий double эл-т стека
//		    }
//		    break;
//		    case 'i':  
//				for (j = 0; j<i; j++)
//		    {
//				**((int**)sum + 0) += *(int *)p;         // накопление суммы элементов int
//				(int*)p = ((int*)p) + 1;                       // p перемещается на следующий double эл-т стека
//		    }
//		}
//	}
//	puts("\n\nвывод результата в функции var_fun :");
//	printf(" \n  сумма int= %d  сумма float= %5.2lf", **((int**)sum), **((double**)sum + 1));
//
//
//	return sum;
//}




//----------------------------------  пример 3  ------------------------------------------

//enum Type{Char,Int,Float};
////void var_fun(enum Type, ...);                 // прототип функции с переменным числом параметров
//
//int main()
//{ 
//   void var_fun(enum Type, ...);                 // прототип функции с переменным числом параметров
//
//   var_fun(Char, 'a', 'b', 'c', 'd', 'e', '\0'); // несколько вызовов функции с передачей ей разного 
//   var_fun(Int, 3, 4, 7, 9, 0);                  // числа и типа параметров с указанием признака 
//   var_fun(Float, 1.2, (float)5, 5., (float)0);  // типа параметров 
//   puts("\n");
//   return  0;
//}
//
//void var_fun(enum Type t,...)      // переменная t принимает значение типа enum Type
//{ char c;
//  void *p=&t;                      // все как и в предыдущих функциях
//  p=((int *)p)+1;
//  puts("\n");
//  switch(t)
//  { case Char : while(*(char *)p)  
//                {
//	  printf("%c",*(char *)p);
//	  p=((int *)p)+1;
//                } break;
//
//
//    case Int  : while(*(int *)p)   
//				{ printf("%3d",*(int *)p);p=((int *)p)+1;} break;
//    case Float: while(*(double *)p)
//				{ printf("%5.2f",*((double *)p));p=((double *)p)+1;}
//   }
//}



//----------------------------------  пример 4  ----------------------------------------

// реализация функции с произвольным числом параметров различного типа
// доступ к данным (параметрам) реализован с использованием системных
// макрос ( va_list,  va_start, va_arg,  va_end).

//#include <stdarg.h>
//enum data{Int,Float=2} tp;
//
//void var_fun(int k, int l, enum data tp, ...)    // k-число групп
//{ 
//  int si=0;            // сумма целочисленных значений
//  float sf=0;          // сумма вещественных значений
//  va_list p;           // p - безтиповой указатель
//  va_start(p,tp);      // указатель на параметр стека следующий за tp 
//  while(k--)           // пока количество параметров в стке не равно 0
//  { switch(tp)         // определяем тип параметров (переменных)
//    { case Int : while(l--)         // пока не считаны все переменные группы
//		   si+=va_arg(p,int);       // сумма int (считываем из стека int параметр 
//           break;                   // и передвигаем указатель p на следующий параметр
//	  case Float: while (l--)
//	  //case 2: while(l--)            // пока не считаны все переменные группы
//		   sf+=va_arg(p,double);    // сумма double (float)
//		   break;
//    }
//    l=va_arg(p,int);          // считывается число элементов в группе (int)
//    tp=va_arg(p,enum data);   // считывается признак типа элементов группы
//  }
//  va_end(p);
//  printf("\n  si= %d   sf= %lf\n",si,sf);
//}
//
//int main()
//{ 
//  var_fun(3, 2, Int, 1, 2, 3, Float, 1.2, .8, 2.5, 4, Int, 2, 3, 4, 5);
//  printf("\n");
//  return 0;
//}




//----------------------------------  пример 6  -------------------------------------
// реализация функции с произвольным числом параметров различного типа
// в качестве параметров в функцию передаются указатели на числовые  
// массивы данных. Доступ к данным (параметрам) реализован с использованием 
// void **ii (для указателей на массив)  void * (для значений числа массивов 
// и их размерности)
//void var_fun(int,...);
//
//int main()
//{ setlocale(LC_ALL,"Russian" );
//  int *m1, *m2;                     // указателей (массивов) м.б. сколько угодно
//  m1 = (int*)calloc(3,sizeof(int));
//
//  for (int i = 0; i < 3; i++) 
//	  m1[i] = i + 1; 
//
//  m2 = (int*)calloc(4, sizeof(int));
//  for (int i = 0; i < 4; i++)
//	  m2[i] = i + 5;
//
//  var_fun(2,3,m1,4,m2);
//  return 0;
//}
//       
//void var_fun(int n,...)  // n-число групп (массивов)
//{ int k;
//  void **ii;            
//  void *jj;
//  jj = (void*)(int *)&n;   // считывается число указателей на массивы (т.е. число массивов) (2)
//  printf("%3d", *(int*)jj);
//
//  jj=(void*)((int*)jj + 1); 
//  k = *((int*)jj);       // число - размерность первого массива (3)
//
//  while (1)
//  {	  printf("\n");
//	  printf("%3d   ", k);
//	  ii = (void**)((int*)jj + 1);         // устанавливаем ii - указатель на массив
//	  for (int i = 0; i < k; i++)          // вывод очередного массива
//		  printf("%3d", *(*(int**)ii + i));
//
//	  if (!--n) break;                     // все массивы просмотрены
//
//	  (int**)ii++; (int**)ii++;            // ii на слелующий указатель в стеке
//	  //ii=(void**)((int**)ii+1); // заменяет две предыдущие интрукции
//	  jj = (int*)jj + 2;                   // jj на следующую размерность в стеке
//	  k = *(int*)jj;                       // считываем размерность следующего массива
//  }
//  printf("\n\n");
//}


//----------------------------------  пример 7  -------------------------------------
// реализация функции с произвольным числом параметров различного типа
// в качестве параметров в функцию передаются указатели на числовые  
// массивы данных. Доступ к данным (параметрам) реализован с использованием 
// системных макрос ( va_list,  va_start, va_arg,  va_end)
//#include <stdarg.h>
//void var_fun(int, ...);
//
//int main()
//{
//	setlocale(LC_ALL, "Russian");
//	int *m1, *m2;                     // указателей (массивов) м.б. сколько угодно
//	m1 = (int*)calloc(3, sizeof(int));
//	for (int i = 0; i < 3; i++) m1[i] = i + 1;
//	m2 = (int*)calloc(4, sizeof(int));
//	for (int i = 0; i < 4; i++) m2[i] = i + 5;
//	var_fun(2, 3, m1, 4, m2);
//	return 0;
//}
//
//void var_fun(int n, ...)              // n-число групп (массивов)
//{
//	int k;
//	va_list p;                         // объявление переменной типа va_list 
//	va_start(p, n);                     // указатель р устанавливается на начало переменного 
//	int *ptr;
//	while (1)
//	{
//		k = va_arg(p, int);            // считывается размерность очередного массива
//		printf("%3d\n", k);
//		ptr = va_arg(p, int*);
//		for (int i = 0; i < k; i++)    // вывод очередного массива
//			printf("%3d", *(ptr + i));
//		if (!--n) break;               // все массивы просмотрены
//	}
//	printf("\n\n");
//	va_end(p);
//}











